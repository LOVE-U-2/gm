<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Catch the Fruit ‚Äî Mobile Fixed</title>
<style>
  :root{
    --bg1:#9be7ff; --bg2:#e8f8ff; --accent:#ff7a7a; --muted:#666;
  }
  *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;padding:0;margin:0}
  body{background:linear-gradient(180deg,var(--bg1),var(--bg2));color:#111;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:18px}
  .wrap{width:100%;max-width:1100px}
  .card{background:#fff;border-radius:14px;overflow:hidden;box-shadow:0 16px 40px rgba(10,30,60,0.08)}
  .header{display:flex;justify-content:space-between;align-items:center;padding:14px 18px;background:linear-gradient(90deg,#fff8f7,#fffef9)}
  .main{display:grid;grid-template-columns:1fr 320px;gap:14px;padding:14px}
  @media (max-width:900px){ .main{grid-template-columns:1fr} }
  .canvas-wrap{position:relative;background:linear-gradient(180deg,#c9f2ff,#ffdfe6);padding:12px;border-radius:12px}
  canvas{display:block;width:100%;height:auto;border-radius:10px;background:transparent}
  .controls{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
  button{padding:10px 14px;border-radius:10px;border:0;font-weight:800;cursor:pointer}
  .btn-primary{background:linear-gradient(90deg,var(--accent),#ff9a9a);color:#fff}
  .btn-ghost{background:#fff;border:1px solid #e8e8e8}
  .panel{background:linear-gradient(180deg,#fff,#fffef6);padding:12px;border-radius:10px;box-shadow:0 8px 20px rgba(0,0,0,0.04);margin-bottom:10px}
  .stat-big{font-size:32px;font-weight:800}
  .hint{font-size:13px;color:var(--muted);margin-top:8px}
  /* mobile bigger buttons */
  @media (max-width:600px){
    button{padding:14px 18px;font-size:16px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="header">
        <div>
          <strong style="font-size:18px">üçì Catch the Fruit ‚Äî Fixed</strong>
          <div style="font-size:12px;color:var(--muted)">Mobile + Desktop ‚Äî auto-fit, touch-friendly</div>
        </div>
        <div style="display:flex;gap:10px;align-items:center">
          <div id="lives" style="padding:6px 10px;background:rgba(255,255,255,0.85);border-radius:999px">‚ù§ x3</div>
          <div id="time" style="padding:6px 10px;background:rgba(255,255,255,0.85);border-radius:999px">‚è± 60s</div>
          <div id="score" style="padding:6px 10px;background:rgba(255,255,255,0.85);border-radius:999px">‚≠ê 0</div>
        </div>
      </div>

      <div class="main">
        <section>
          <div class="canvas-wrap" id="canvasWrap">
            <canvas id="gameCanvas" width="900" height="520" aria-label="game"></canvas>
            <canvas id="confetti" width="900" height="520" style="position:absolute;left:0;top:0;pointer-events:none"></canvas>
          </div>

          <div class="controls">
            <button id="startBtn" class="btn-primary">Start</button>
            <button id="pauseBtn" class="btn-ghost">Pause</button>
            <button id="muteBtn" class="btn-ghost">üîä</button>
            <div style="flex:1"></div>
            <div class="hint">Move: Mouse / Touch-drag or tap left/right on mobile ‚Ä¢ ‚Üê ‚Üí keys</div>
          </div>
        </section>

        <aside>
          <div class="panel">
            <div style="font-size:12px;color:var(--muted)">Score</div>
            <div id="scoreBig" class="stat-big">0</div>
          </div>

          <div class="panel">
            <div style="font-size:12px;color:var(--muted)">Level</div>
            <div id="levelBig" class="stat-big">1</div>
          </div>

          <div class="panel">
            <div style="font-size:12px;color:var(--muted)">High Score</div>
            <div id="highScore" class="stat-big">0</div>
          </div>

          <div class="panel" style="font-size:13px;color:var(--muted)">
            Tap left/right half to nudge the basket. Drag to follow. Game adjusts basket size & speed for phones.
          </div>
        </aside>
      </div>
    </div>
  </div>

<script>
(() => {
  // elements
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const confetti = document.getElementById('confetti');
  const cctx = confetti.getContext('2d');

  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const muteBtn = document.getElementById('muteBtn');
  const scoreLabel = document.getElementById('score');
  const scoreBig = document.getElementById('scoreBig');
  const levelBig = document.getElementById('levelBig');
  const livesLabel = document.getElementById('lives');
  const timeLabel = document.getElementById('time');
  const highScoreEl = document.getElementById('highScore');

  const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

  // state
  let W = 900, H = 520;
  let running = false, paused = false;
  let score = 0, lives = 3, level = 1, timeLeft = 60;
  let fruits = [];
  const emojis = ['üçé','üçä','üçá','üçå','üçì','üçâ','ü•ù','üçç'];
  let basket = { x: 450, y: 450, w: 260, h: 50 };

  const HIGH_KEY = 'catchFruit_high_v3';
  let highScore = parseInt(localStorage.getItem(HIGH_KEY) || '0', 10);
  highScoreEl.textContent = highScore;

  // audio
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = AudioCtx ? new AudioCtx() : null;
  function beep(freq=440, dur=0.06){
    if(!audioCtx) return;
    if(beep.muted) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine'; o.frequency.value = freq;
    g.gain.value = 0.06;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + dur);
  }
  beep.muted = false;

  // robust fit - runs on load and resize
  function fitCanvas(){
    // ensure parent exists and has size
    const wrap = document.getElementById('canvasWrap');
    const rect = wrap.getBoundingClientRect();
    if(rect.width === 0){
      // maybe not yet laid out; try later
      requestAnimationFrame(fitCanvas);
      return;
    }
    const ratio = window.devicePixelRatio || 1;
    // base aspect 900x520 -> scale by element width
    canvas.width = Math.round(rect.width * ratio);
    canvas.height = Math.round((rect.width / 900) * 520 * ratio);

    canvas.style.width = rect.width + 'px';
    canvas.style.height = (rect.width / 900) * 520 + 'px';

    confetti.width = canvas.width;
    confetti.height = canvas.height;
    confetti.style.width = canvas.style.width;
    confetti.style.height = canvas.style.height;

    W = canvas.width;
    H = canvas.height;

    // scale basket to new canvas
    basket.w = Math.max(120, Math.round(W * (isMobile ? 0.45 : 0.28)));
    basket.h = Math.max(36, Math.round(H * 0.10));
    basket.y = Math.round(H - basket.h * 1.5);
    basket.x = Math.max(basket.w/2, Math.min(W - basket.w/2, basket.x || W/2));
  }

  // call fit on load + resize
  window.addEventListener('resize', () => { fitCanvas(); draw(); });
  window.addEventListener('orientationchange', () => { setTimeout(()=>{ fitCanvas(); draw(); }, 120); });
  // initial
  requestAnimationFrame(fitCanvas);

  // spawn logic (uses timestamp)
  let lastSpawn = 0;
  function spawn(timestamp){
    // spawn based on time; spawn slower on mobile
    const now = timestamp || performance.now();
    const interval = isMobile ? 1100 : 700;
    if(now - lastSpawn >= interval){
      lastSpawn = now;
      const size = Math.round(Math.random()*40 + 36);
      const rawSpeed = Math.random()*120 + 150; // px/s scaled to canvas pixels
      const speed = rawSpeed * (isMobile ? 0.65 : 1);
      fruits.push({ x: Math.random()*(W-80)+40, y: -size, size, vy: speed, emoji: emojis[Math.floor(Math.random()*emojis.length)] });
    }
  }

  // draw
  function draw(){
    ctx.clearRect(0,0,W,H);
    // background
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#b8f0ff'); g.addColorStop(1,'#fff6f3');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

    // ground
    ctx.fillStyle = '#fff6e6';
    ctx.fillRect(0, H*0.72, W, H*0.28);

    // fruits
    fruits.forEach(f => {
      ctx.font = (f.size) + 'px serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(f.emoji, f.x, f.y);
      // shadow
      ctx.beginPath();
      ctx.ellipse(f.x+12, f.y + f.size/2 + 10, f.size/3, f.size/10, 0, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(0,0,0,0.06)';
      ctx.fill();
    });

    // basket
    const bx = basket.x - basket.w/2, by = basket.y - basket.h/2;
    roundRect(ctx, bx, by, basket.w, basket.h, Math.max(10, basket.h/2));
    ctx.fillStyle = '#6a4bff'; ctx.fill();

    // rim
    ctx.fillStyle = '#ffd6d6';
    ctx.fillRect(bx, by-8, basket.w, 12);

    // stats overlays (already in DOM but update small in-canvas UI)
  }

  function roundRect(c, x, y, w, h, r){
    c.beginPath();
    c.moveTo(x+r, y);
    c.arcTo(x+w, y, x+w, y+h, r);
    c.arcTo(x+w, y+h, x, y+h, r);
    c.arcTo(x, y+h, x, y, r);
    c.arcTo(x, y, x+w, y, r);
    c.closePath();
  }

  function updateUI(){
    scoreLabel.textContent = '‚≠ê ' + score;
    scoreBig.textContent = score;
    levelBig.textContent = level;
    livesLabel.textContent = '‚ù§ x' + lives;
    timeLabel.textContent = '‚è± ' + Math.max(0, Math.ceil(timeLeft)) + 's';
  }

  // game loop (stable dt in seconds)
  let lastFrame = 0;
  function loop(ts){
    if(!lastFrame) lastFrame = ts;
    const dtMs = ts - lastFrame;
    const dt = Math.min(40, dtMs) / 1000; // limit to 40ms per frame to avoid giant jumps
    lastFrame = ts;

    if(running && !paused){
      // spawn based on time
      spawn(ts);

      // update fruits
      for(let i = fruits.length-1; i >= 0; i--){
        const f = fruits[i];
        // move (vy is in px/s relative to canvas px)
        f.y += f.vy * dt;

        // collision with basket
        const basketTop = basket.y - basket.h/2;
        const basketLeft = basket.x - basket.w/2;
        const basketRight = basket.x + basket.w/2;
        if(f.y + f.size/2 >= basketTop && f.x >= basketLeft && f.x <= basketRight){
          // caught
          score++;
          // level up every 10 points
          const newLevel = Math.floor(score/10) + 1;
          if(newLevel > level) {
            level = newLevel;
            // small beep/maybe confetti
            pulseConfetti();
            if(audioCtx && audioCtx.state !== 'suspended') beep(1200, 0.08);
          }
          fruits.splice(i,1);
          continue;
        }
        // missed -> below canvas
        if(f.y - f.size/2 > H + 40){
          fruits.splice(i,1);
          lives--;
          if(audioCtx && audioCtx.state !== 'suspended') beep(220, 0.06);
          if(lives <= 0){
            endGame();
            break;
          }
        }
      }

      // time decrement (1 second per real second)
      timeLeft -= dt;
      if(timeLeft <= 0){
        endGame();
      }
      updateUI();
    }

    // draw every frame
    draw();

    // confetti animation handled separately
    requestAnimationFrame(loop);
  }

  // start the loop
  requestAnimationFrame(loop);

  // game control
  function startGame(){
    // resume audio on gesture
    try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }catch(e){}
    running = true; paused = false;
    score = 0; lives = 3; level = 1; timeLeft = 60;
    fruits = [];
    lastSpawn = performance.now();
    lastFrame = 0;
    updateUI();
  }

  function endGame(){
    running = false;
    paused = false;
    // save high score
    if(score > highScore){
      highScore = score;
      localStorage.setItem(HIGH_KEY, String(highScore));
      highScoreEl.textContent = highScore;
    }
    updateUI();
    pulseConfetti();
    setTimeout(()=>{ alert(`Game over!\nScore: ${score}\nHigh Score: ${highScore}`); }, 120);
  }

  startBtn.addEventListener('click', ()=>{ startGame(); });
  pauseBtn.addEventListener('click', ()=>{ if(!running) return; paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; });
  muteBtn.addEventListener('click', ()=>{ beep.muted = !beep.muted; muteBtn.textContent = beep.muted ? 'üîá' : 'üîä'; });

  // input handling (mouse move, touch drag, tap halves)
  canvas.addEventListener('mousemove', (ev)=>{
    if(!running) return;
    const r = canvas.getBoundingClientRect();
    const x = (ev.clientX - r.left) * (canvas.width / r.width);
    basket.x = Math.max(basket.w/2, Math.min(W - basket.w/2, x));
  });

  // touch drag
  let activeTouchId = null;
  canvas.addEventListener('touchstart', (ev)=>{
    if(!running) return;
    const t = ev.changedTouches[0];
    activeTouchId = t.identifier;
    const r = canvas.getBoundingClientRect();
    const x = (t.clientX - r.left) * (canvas.width / r.width);
    // if they tapped (quick touch) we allow tap to move by a chunk; dragging will be handled by touchmove
    basket.x = Math.max(basket.w/2, Math.min(W - basket.w/2, x));
  }, {passive:true});

  canvas.addEventListener('touchmove', (ev)=>{
    if(!running) return;
    // find our touch
    let t = ev.changedTouches[0];
    for(let i=0;i<ev.touches.length;i++){
      if(activeTouchId === ev.touches[i].identifier) { t = ev.touches[i]; break; }
    }
    const r = canvas.getBoundingClientRect();
    const x = (t.clientX - r.left) * (canvas.width / r.width);
    basket.x = Math.max(basket.w/2, Math.min(W - basket.w/2, x));
  }, {passive:false});

  canvas.addEventListener('touchend', (ev)=>{
    activeTouchId = null;
  }, {passive:true});

  // also support tap-left/right quick nudges when not dragging
  canvas.addEventListener('click', (ev)=>{
    if(!running) return;
    const r = canvas.getBoundingClientRect();
    const x = (ev.clientX - r.left) * (canvas.width / r.width);
    if(x < r.width/2) basket.x -= basket.w * 0.6;
    else basket.x += basket.w * 0.6;
    basket.x = Math.max(basket.w/2, Math.min(W - basket.w/2, basket.x));
  });

  // keyboard control
  window.addEventListener('keydown', (e)=>{
    if(!running) return;
    if(e.key === 'ArrowLeft') basket.x -= Math.max(40, basket.w*0.25);
    if(e.key === 'ArrowRight') basket.x += Math.max(40, basket.w*0.25);
    basket.x = Math.max(basket.w/2, Math.min(W - basket.w/2, basket.x));
  });

  // confetti (simple)
  let confettiPieces = [], confettiLast = 0;
  function burstConfetti(){
    confettiPieces = [];
    for(let i=0;i<120;i++){
      confettiPieces.push({ x: Math.random()*confetti.width, y: Math.random()*-confetti.height, vx: (Math.random()-0.5)*0.6, vy: 1 + Math.random()*4, r: 4+Math.random()*8, c: `hsl(${Math.random()*360},80%,60%)`, life: 500+Math.random()*1800 });
    }
    if(confettiPieces.length) requestAnimationFrame(animConfetti);
  }
  function pulseConfetti(){
    confettiPieces = [];
    for(let i=0;i<40;i++){
      confettiPieces.push({ x: confetti.width*0.5 + (Math.random()-0.5)*confetti.width*0.6, y: confetti.height*0.1 + Math.random()*confetti.height*0.4, vx: (Math.random()-0.5), vy: -1 + Math.random()*4, r: 4+Math.random()*8, c: `hsl(${Math.random()*360},80%,60%)`, life: 300+Math.random()*900 });
    }
    if(confettiPieces.length) requestAnimationFrame(animConfetti);
  }
  function animConfetti(ts){
    if(!confettiLast) confettiLast = ts;
    const dt = ts - confettiLast; confettiLast = ts;
    cctx.clearRect(0,0,confetti.width,confetti.height);
    for(let i=confettiPieces.length-1;i>=0;i--){
      const p = confettiPieces[i];
      p.x += p.vx * dt * 0.06;
      p.y += p.vy * dt * 0.06;
      p.vy += 0.0008 * dt;
      p.life -= dt;
      cctx.fillStyle = p.c;
      cctx.fillRect(p.x, p.y, p.r, p.r*0.6);
      if(p.life <= 0 || p.y > confetti.height + 50) confettiPieces.splice(i,1);
    }
    if(confettiPieces.length) requestAnimationFrame(animConfetti);
    else confettiLast = 0;
  }

  // small demo mode when idle
  let demoLast = 0;
  function demoLoop(ts){
    if(running) { demoLast = 0; return; }
    if(!demoLast) demoLast = ts;
    const dt = ts - demoLast; demoLast = ts;
    // spawn gently
    if(Math.random() < 0.02) {
      fruits.push({ x: Math.random()*(W-80)+40, y:-80, size: Math.random()*36+30, vy: 40 + Math.random()*60, emoji: emojis[Math.floor(Math.random()*emojis.length)] });
    }
    // move demo fruits
    for(let i=fruits.length-1;i>=0;i--){
      fruits[i].y += fruits[i].vy * (dt/1000);
      if(fruits[i].y > H + 60) fruits.splice(i,1);
    }
    draw();
    requestAnimationFrame(demoLoop);
  }
  requestAnimationFrame(demoLoop);

  // helper to ensure audio resumes on gesture
  ['click','touchstart','keydown'].forEach(ev => window.addEventListener(ev, ()=> { try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }catch(e){} }));

  // initial UI update
  updateUI();
})();
</script>
</body>
</html>
